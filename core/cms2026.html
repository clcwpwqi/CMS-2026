class BrowserCrypto {
    constructor() {
        this.algo = { name: 'AES-GCM', length: 256 };
        this.pbkdf2 = { name: 'PBKDF2', hash: 'SHA-256', iterations: 100000 };
    }

    /**
     * 加密函数
     * @param {string} plaintext - 原始内容（支持中文、Emoji）
     * @param {string} password - 密码
     * @returns {Promise<string>} - Base64编码的加密字符串
     */
    async encrypt(plaintext, password) {
        try {
            const encoder = new TextEncoder();
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const key = await this._deriveKey(password, salt);
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encoder.encode(plaintext)
            );

            // 拼接数据: Salt(16) + IV(12) + Ciphertext
            const buffer = new Uint8Array(salt.byteLength + iv.byteLength + encrypted.byteLength);
            buffer.set(salt, 0);
            buffer.set(iv, salt.byteLength);
            buffer.set(new Uint8Array(encrypted), salt.byteLength + iv.byteLength);

            return this._arrayBufferToBase64(buffer);
        } catch (e) {
            console.error("Encryption Failed:", e);
            throw new Error("加密失败");
        }
    }

    /**
     * 解密函数
     * @param {string} encryptedBase64 - 加密后的Base64字符串
     * @param {string} password - 密码
     * @returns {Promise<string>} - 解密后的原始内容
     */
    async decrypt(encryptedBase64, password) {
        try {
            const buffer = this._base64ToArrayBuffer(encryptedBase64);
            const salt = buffer.slice(0, 16);
            const iv = buffer.slice(16, 28);
            const data = buffer.slice(28);

            const key = await this._deriveKey(password, salt);
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );

            return new TextDecoder().decode(decrypted);
        } catch (e) {
            console.error("Decryption Failed:", e);
            throw new Error("解密失败：密码错误或数据损坏");
        }
    }

    // --- 内部辅助方法 ---

    async _deriveKey(password, salt) {
        const keyMaterial = await crypto.subtle.importKey(
            'raw', 
            new TextEncoder().encode(password), 
            { name: 'PBKDF2' }, 
            false, 
            ['deriveKey']
        );
        return crypto.subtle.deriveKey(
            { ...this.pbkdf2, salt: salt },
            keyMaterial,
            this.algo,
            false,
            ['encrypt', 'decrypt']
        );
    }

    _arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    _base64ToArrayBuffer(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes.buffer;
    }
}
